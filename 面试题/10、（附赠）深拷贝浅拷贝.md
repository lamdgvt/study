#### 深拷贝浅拷贝

##### 为什么会出现深拷贝，浅拷贝
> 由于 js 简单数据类型和复杂数据类型存储的方式不同，导致出现浅拷贝

+ 简单数据类型的存储方式
+ 复杂数据类型的存储方式

```javascript
let a = 1
let b = a
b = 2
console.log(a)//1
console.log(b)//2

let objA = {
  name:'张三',
  age:13
}

let objB = objA
objB.name = "李四"

console.log(objA.name)// 李四
console.log(objB.name)// 李四
```

+ 浅拷贝
> 只是拷贝引用类型的地址，会造成数据的污染


+ 解决方案

  + JSON.parse(JSON.stringify())
  ```javascript
  let objA = {
    name: '张三',
    age: 13
  }

  let objB = objA
  objB = JSON.parse(JSON.stringify(objA))
  objB.name = "李四"

  console.log(objA.name) // 张三
  console.log(objB.name) // 李四
  ```
    + JSON.parse(JSON.stringify)的问题
      + 1、JSON.parse 必须是标准格式的JSON字符串 
      ```javascript
      let objC = '{ name:"asd" }'
      console.log(JSON.parse(objC))//报错
      ```
      + 2、不能拷贝函数，undefined,RegExp,Error对象，NaN,Infinity,-Infinity，会变成null，但是二级以下的也是深拷贝
      ```javascript
        let objA = {
        name: '张三',
        age: 13,
        date: new Date(),
        RegExp: /(a|b)/g,
        Error: new Error('err'),
        NaN: Number('NaN'),
        sayHi: function () {
          console.log('sayHi')
        }
      }

      let objB = objA
      objB = JSON.parse(JSON.stringify(objA))
      console.log(objA.sayHi())
      console.log(objB.sayHi())//报错
      ```
  + Object.assgin(参数1，参数2)
  > Object.assgin第一个参数是需要拷贝的对象，第二个参数是数据源
  ```javascript
  let objA = {
    name: '张三',
    age: 13,
    sayHi: function () {
      console.log('sayHi:' + this.name)
    },
  }
  let obja = {
    sex: '女'
  }
  let objB = new Object
  Object.assign(objB, objA, obja)
  objB.name = '李四'
  console.log(objA.sayHi())
  console.log(objB.sayHi())
  ```
    + 问题：第一级属性是深拷贝，后面的是浅拷贝，但是可以拷贝函数
    ```javascript
    let objA = {
    name: '张三',
    age: 13,
    sayHi: function () {
      console.log('sayHi:' + this.name)
    },
    obj: {
      name: '王二麻子'
    }
  }
  let obja = {
    sex: '女'
  }
  let objB = new Object
  Object.assign(objB, objA, obja)
  objB.obj.name = '狗剩子'
  console.log(objA.obj.name)
  console.log(objB.obj.name)
    ```

  + 递归方式

  ```javascript
    let objA = {
    name: '张三',
    age: 13,
    sayHi: function () {
      console.log('sayHi:' + this.name)
    },
    obj: {
      name: '王二麻子'
    }
  }

  function deepClone(obj) {
    let newObj = null
    if (typeof (obj) == 'object' && obj !== null) {
      newObj = obj instanceof Array ? [] : {}
      for (let i in obj) {
        newObj[i] = deepClone(obj[i])
      }
    } else {
      newObj = obj
    }
    return newObj
  }

  let objB = deepClone(objA)
  objB.obj.name = "狗剩"
  console.log(objA)
  console.log(objB)
  ```

