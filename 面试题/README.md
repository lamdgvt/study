``` 
一.
每一个构造函数(class) 都会有一个 原型对象
1. __proto__ 是实例对象 指向原型对象
2. prototype 是构造函数 指向原型对象  (es5就是通过 该方法进行添加可继承属性或方法)
3. __proto__ 和 prototype 都是指向 原型对象, 区别在于所在的位置不同.
4. 原型对象主要功能是用于继承属性方法
5. instanceof 可以用于当前实例对象的 构造函数的 name


二.
回流(重排)和重绘
浏览器 使用渲染引擎 解析HTML代码
会生成 DOM 树 和 解析 css 样式表 生成 CSSOM 树
DOM树 + CSSOM 树 = Render 渲染树

重绘：渲染树节点发生改变，但不影响该节点在页面当中的空间位置及大小。譬如某个div标签节点的背景颜色、字体颜色等等发生改变，但是该div标签节点的宽、高、内外边距并不发生变化，此时触发浏览器重绘（repaint）;

回流：也有称重排，当渲染树节点发生改变，影响了节点的几何属性（如宽、高、内边距、外边距、或是float、position、display：none;等等），导致节点位置发生变化，此时触发浏览器重排（reflow），需要重新生成渲染树。譬如JS为某个p标签节点添加新的样式："display:none;"。导致该p标签被隐藏起来，该p标签之后的所有节点位置都会发生改变。此时浏览器需要重新生成渲染树，重新布局，即回流（reflow）

回流一定会触发重绘，重绘不一定会触发回流。


三.
vue 双向绑定的原理
vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属
性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和
getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化

第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每
个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
黑马程序员

第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:
1、在自身实例化时往属性订阅器(dep)里面添加自己
2、自身必须有一个update()方法
3、待属性变动dep.notice()通知时，能调用自身的 update() 方法，并触发Compile中绑定的回
调，则功成身退。

第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer
来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和
Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向
绑定效果。


四.
输入url 到页面渲染 这中间发生了什么
1.	DNS 解析url解析成 ip地址。DNS 就是个数据库 根据url 查询数据里对应的 ip地址.
2.	TCP 三次握手建立TCP连接、客户端发送 SYN 数据包、服务器相应SYN 和 ACK 数据包同意建立、客户端发送ACK数据包 成功连接.
3.	发送HTTP 请求报文服务器，请求行、请求头部、空行、请求数据。
4.	响应HTTP 请求，请求行、请求头部、空行、响应数据。
5.	页面渲染、解析HTML、CSS、JS
6.  四次挥手、客户端 或者 服务端都可以发起关闭连接请求
    (1)、客户端发起关闭连接 发送 FIN 包 、进入等待1 状态
    (2)、服务端发送 ACK 包 进入关闭等待状态、 客户端进入等待2状态
    (3)、服务端继续发送 FIN 包 进入确认状态、客户端回复 ACK 包 进入超时等待状态 经过超时关闭连接
    (4)、服务端收到 ACK 包后 马上关闭连接


五.
DNS域名解析
    www.bilibili.com
    www         为 主机名 二级域名
    bilibili    为 域名
    com         为 顶级域名
    .           为 根域名
过程
    1. 浏览器缓冲查询有没有对应的解析过该域名的 ip 记录 或者 有没有本地对应记录
    2. 假设没有
    3. DNS 客户端 向 DNS 服务器服务器查询 ip 地址

六.
垃圾回收制

七.
栈(stack)和堆(heap)


```